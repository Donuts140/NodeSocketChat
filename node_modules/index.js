const express = require('express');
const app = express();
const server = require('http').createServer(app);
const io = require('socket.io')(server);
const fs = require('fs');
const path = require('path');
const cookieParser = require('cookie-parser');

app.use(cookieParser());
app.use(express.static('public'));

app.get('/', (req, res) => {
  res.sendFile(__dirname + '/public/index.html');
});

const users = {};  // Objet pour stocker les utilisateurs connectés {socketId: pseudo}
const serverLogPath = path.join(__dirname, 'server.log');
const messageLogPath = path.join(__dirname, 'messages.log');

// Vérification si les fichiers existent, sinon création
if (!fs.existsSync(serverLogPath)) {
    fs.writeFileSync(serverLogPath, '', 'utf8');
}
if (!fs.existsSync(messageLogPath)) {
    fs.writeFileSync(messageLogPath, '', 'utf8');
}

io.on('connection', (socket) => {
    let pseudo = 'Anonymous';  // Valeur par défaut
    console.log('User connected at ' + new Date() + ' with id: ' + socket.id);

    // Lorsque le client envoie son pseudo
    socket.on('set pseudo', (pseudoFromClient) => {
        pseudo = pseudoFromClient;
        users[socket.id] = pseudo;  // Enregistrer le pseudo avec le socket.id
        console.log(`User ${pseudo} connected`);

        // Log de connexion dans server.log
        const logMessage = `CONNEXION - ${pseudo} at ${new Date().toISOString()} with ID: ${socket.id}\n`;
        fs.appendFile(serverLogPath, logMessage, (err) => {
            if (err) {
                console.error('Failed to save connection log:', err);
            }
        });

        // Emission de la liste mise à jour des utilisateurs connectés à tous les clients
        io.emit('connected users', { count: Object.keys(users).length, users: Object.values(users) });
    });

    // Lors de la déconnexion de l'utilisateur
    socket.on('disconnect', () => {
        console.log(`User ${pseudo} disconnected at ${new Date()} with id: ${socket.id}`);

        // Log de déconnexion dans server.log
        const disconnectLog = `DECONNEXION - ${pseudo} at ${new Date().toISOString()} with ID: ${socket.id}\n`;
        fs.appendFile(serverLogPath, disconnectLog, (err) => {
            if (err) {
                console.error('Failed to save disconnection log:', err);
            }
        });

        // Retirer l'utilisateur de la liste des connectés
        delete users[socket.id];

        // Emission de la liste mise à jour des utilisateurs connectés à tous les clients
        io.emit('connected users', { count: Object.keys(users).length, users: Object.values(users) });
    });

    // Charger et afficher les messages précédents
    fs.readFile(messageLogPath, 'utf8', (err, data) => {
        if (err) {
            console.error('Failed to read message log:', err);
            return;
        }
        const messages = data.split('\n').filter(line => line.trim() !== '').map(line => {
            const parts = line.split(' - ');
            return parts.length > 1 ? parts[1] : line;
        });
        socket.emit('load messages', messages);
    });

    // Envoi de message
    socket.on('chat message', (messageData) => {
        console.log('message:', messageData);

        // Diffuser le message à tous les utilisateurs
        io.emit('chat message', messageData);

        // Enregistrer le message dans le fichier messages.log
        const logMessage = `${new Date().toISOString()} - ${messageData.pseudo}: ${messageData.text}\n`;
        fs.appendFile(messageLogPath, logMessage, (err) => {
            if (err) {
                console.error('Failed to save message:', err);
            }
        });
    });
});

server.listen(3000, () => {
    console.log('listening on *:3000');
});
